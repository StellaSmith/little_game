#!/bin/env python3
# encoding: utf-8
# SPDX-FileCopyrightText: 2023 Stella Smith
# SPDX-License-Identifier: GPL-2.0-or-later

import argparse
import logging
import sys
from dataclasses import dataclass
from pathlib import Path, PurePosixPath
from typing import Generator, Callable, Any
import os
import json
import itertools


@dataclass
class Filter:
    name: str
    pattern: dict[str, Any]
    function: Callable


FILTERS = {}


def filter(function: Callable) -> Callable:
    FILTERS[function.__name__] = Filter(function.__name__, function.__annotations__, function)
    return function


@dataclass
class BaseResource:
    path: Path


@dataclass
class DirectoryResource(BaseResource):
    entries: list[Path]


@dataclass
class FileResource(BaseResource):
    data: bytes


@dataclass
class SymlinkResource(BaseResource):
    target: Path


def add_file(path: Path) -> FileResource:
    data = open(path, "rb").read()
    return FileResource(Path(path), data)


def add_symlink(path: Path) -> SymlinkResource:
    target = os.readlink(path)
    return SymlinkResource(Path(path), target)


def add_directory(path: Path) -> Generator[BaseResource, None, DirectoryResource]:
    entries = []
    for entry in os.scandir(path):
        entries.append(Path(entry.path))
        if entry.is_dir():
            yield from add_directory(entry.path)
        elif entry.is_file():
            yield add_file(entry.path)
        elif entry.is_symlink():
            yield add_symlink(entry.path)
        else:
            result = entry.stat(follow_symlinks=False)
            raise TypeError(f"unknown file kind of {entry} (st_mode={result.st_mode})")
    res = DirectoryResource(Path(path), entries)
    yield res
    return res


@filter
def minify_json(resource: BaseResource):
    from decimal import Decimal

    # make sure (de)serialized decimals dont lose precision
    def serialize_decimal(decimal: Decimal):
        if isinstance(decimal, Decimal):
            return str(decimal)
        return decimal

    if isinstance(resource, FileResource) and resource.path.suffix == ".json":
        resource: FileResource
        parsed = json.loads(resource.data,  parse_float=Decimal)
        data = json.dumps(parsed, separators=(",", ":"), default=serialize_decimal).encode("utf-8")
        return FileResource(resource.path, resource)
    else:
        return resource


@filter
def as_posix(resource: BaseResource):
    resource.path = resource.path.as_posix()
    if resource.path == ".":
        resource.path = "/"
    resource.path = PurePosixPath(resource.path)
    return resource


def chunked(iterator, n):
    iterator = iter(iterator)
    while True:
        to_yield = None
        for _ in range(n):
            try:
                if to_yield is None:
                    to_yield = [next(iterator)]
                else:
                    to_yield.append(next(iterator))
            except StopIteration:
                if to_yield is not None:
                    yield tuple(to_yield)
                return
        yield tuple(to_yield)


def cpp_string_literal(s):
    # there has to be a better way of doing this
    import string
    result = ""
    if isinstance(s, str):
        for char in s:
            if char == '"':
                result += "\\\""
            elif char == "'":
                result += "'"
            else:
                result += ascii(char)[1:-1]
    elif isinstance(s, (bytes, bytearray)):
        for byte in s:
            if byte == ord('"'):
                result += "\\\""
            elif byte == "'":
                result += "'"
            else:
                result += repr(bytes([byte]))[2:-1]
    return f'"{result}"'


def main() -> int:
    parser = argparse.ArgumentParser(description="Compiles a directory into a C/C++ source code file containing the directory structure in static memory")
    parser.add_argument("-V", "--verbose", default=0, help="Be verbose", action="count")
    parser.add_argument("resources_dir", help="Directory containing the resources to compile")
    parser.add_argument("-o", "--output", type=argparse.FileType('w'), default=sys.stdout, help="File to save the generated code")
    parser.add_argument("--filter", dest="filters", action="append", default=[], help="Filters to apply to resources, in order", choices=FILTERS.keys())
    arguments = parser.parse_args()
    if arguments.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    logging.debug(f"{arguments=!r}")
    logging.debug(f"selected filters: {arguments.filters}")

    print(f"\n// THIS FILE WAS AUTOGENERATED BY {parser.prog}\n", file=arguments.output)
    print(f"namespace resources {{\n", file=arguments.output)
    print(f"enum class ResourceType {{\n    DIRECTORY_RESOURCE,\n    FILE_RESOURCE,\n    SYMLINK_RESOURCE\n}};\n", file=arguments.output)
    print(f"struct BaseResource {{\n    ResourceType type;\n    char const *path;\n    char const *basename;\n    unsigned long long size;\n}};\n", file=arguments.output)
    print(f"struct DirectoryResource : BaseResource {{\n    BaseResource const *const *entries;\n}};\n", file=arguments.output)
    print(f"struct FileResource : BaseResource {{\n    unsigned char const *data;\n}};\n", file=arguments.output)
    print(f"struct SymlinkResource : BaseResource {{\n    char const *target;\n}};\n", file=arguments.output)
    print(f"BaseResource const *get_root() noexcept;\n", file=arguments.output)
    print(f"}} // namespace resources\n", file=arguments.output)
    print(f"#if defined(COMPILE_RESOURCES)\n", file=arguments.output)

    indices = {}
    for i, resource in enumerate(add_directory(arguments.resources_dir)):
        resource.path = resource.path.relative_to(arguments.resources_dir)
        if resource.path == ".":
            resource.path = "/"
        for filter in (FILTERS[name] for name in arguments.filters):
            filter: Filter
            logging.debug(f"processing {resource.path!r} with {filter.name!r}")
            resource = filter.function(resource)
        logging.debug(f"generating {resource.path!r}")
        indices[resource.path] = i
        print(f"static char const entry_{i}_path[] = {cpp_string_literal(str(resource.path))};", file=arguments.output)
        if isinstance(resource, DirectoryResource):
            resource: DirectoryResource
            print(f"static resources::BaseResource const* const entry_{i}_data[] = {{", file=arguments.output)
            for entry in sorted(resource.entries):
                entry = entry.relative_to(arguments.resources_dir)
                print(f"    &entry_{indices[entry]},", file=arguments.output)
            print("};", file=arguments.output)

            print(f"static resources::DirectoryResource const entry_{i} = {{", file=arguments.output)
            print(f"    resources::ResourceType::DIRECTORY_RESOURCE,", file=arguments.output)
            print(f"    &entry_{i}_path[0],", file=arguments.output)
            print(f"    &entry_{i}_path[{str(resource.path).rfind(resource.path.name)}],", file=arguments.output)
            if resource.entries:
                print(f"    {len(resource.entries)}uLL,", file=arguments.output)
                print(f"    &entry_{i}_data[0],", file=arguments.output)
            else:
                print(f"    0,", file=arguments.output)
                print(f"    nullptr,", file=arguments.output)

            print("};", file=arguments.output)
        elif isinstance(resource, FileResource):
            resource: FileResource
            if resource.data:
                print(f"static unsigned char const entry_{i}_data[] =", file=arguments.output, end="")
                for chunk in chunked(resource.data, 64):
                    print(f"\n    {cpp_string_literal(bytes(chunk))}", file=arguments.output, end="")
                print(f";", file=arguments.output)

            print(f"static resources::FileResource const entry_{i} = {{", file=arguments.output)
            print(f"    resources::ResourceType::FILE_RESOURCE,", file=arguments.output)
            print(f"    &entry_{i}_path[0],", file=arguments.output)
            print(f"    &entry_{i}_path[{str(resource.path).rfind(resource.path.name)}],", file=arguments.output)

            if resource.data:
                print(f"    {len(resource.data)}uLL,", file=arguments.output)
                print(f"    &entry_{i}_data[0],", file=arguments.output)
            else:
                print(f"    0,", file=arguments.output)
                print(f"    nullptr,", file=arguments.output)
            print("};", file=arguments.output)
        elif isinstance(resource, SymlinkResource):
            resource: SymlinkResource
            print(f"static unsigned char const entry_{i}_data[] = {cpp_string_literal(str(resource.target))};", file=arguments.output)
            print(f"static resources::SymlinkResource const entry_{i} = {{", file=arguments.output)
            print(f"    resources::ResourceType::SYMLINK_RESOURCE,", file=arguments.output)
            print(f"    &entry_{i}_path[0],", file=arguments.output)
            print(f"    &entry_{i}_path[{str(resource.path).rfind(resource.path.name)}],", file=arguments.output)
            print(f"    {len(str(resource.target).encode('utf-8'))}uLL,", file=arguments.output)
            print(f"    &entry_{i}_data[0],", file=arguments.output)
            print("};", file=arguments.output)
        else:
            raise TypeError(f"cannot serialize resource of type {type(resource).__qualname__}", resource)
        print(file=arguments.output)

    print(f"resources::BaseResource const *resources::get_root() noexcept", file=arguments.output)
    print(f"{{", file=arguments.output)
    print(f"    return &entry_{i};", file=arguments.output)
    print(f"}}\n", file=arguments.output)
    print(f"#endif", file=arguments.output)

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
